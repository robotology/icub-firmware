

/*
 * Copyright (C) 2024 iCub Tech - Istituto Italiano di Tecnologia
 * Author:  Marco Accame
 * email:   marco.accame@iit.it
*/

// - include guard ----------------------------------------------------------------------------------------------------

#ifndef _EMBOT_APP_APPLICATION_THECANPARSERMC2_H_
#define _EMBOT_APP_APPLICATION_THECANPARSERMC2_H_

//#include "embot_core.h"
//#include "embot_prot_can.h"
//#include "embot_prot_can_motor_polling.h"
//#include "embot_prot_can_motor_periodic.h"
//#include <vector>
//#include <memory>

#include <vector>
#include <memory>

#include "embot_app_application_CANagentMC2.h"

#include "embot_hw_motor.h"

namespace embot::app::application {
    
           
    class theCANparserMC2
    {
    public:
        static theCANparserMC2& getInstance();
        
        
    public:
        
        static constexpr std::initializer_list<embot::hw::MOTOR> themotors {embot::hw::MOTOR::one, embot::hw::MOTOR::two};    
        static constexpr size_t numberofmotors {themotors.size()}; // {embot::hw::motor::bldc::MAXnumber};       
        
        struct Config
        {
            CANagentMC2* agent {nullptr};
            std::array<uint8_t, numberofmotors> address {1, 2};
            Config() = default;
            constexpr Config(CANagentMC2* agt, const std::array<uint8_t, numberofmotors> adr) : agent(agt), address(adr) {}
            bool isvalid() const { return (nullptr != agent) && (address[0]<4) && (address[1]<4); }
            uint8_t getaddress(embot::hw::MOTOR m)
            {
                uint8_t i = embot::core::tointegral(m);
                return (i < numberofmotors) ? address[i] : 255;
            }            
        }; 
        
        
        bool initialise(const Config &config); 
        
        // mode1:   this is the traditional calling mode: all the frames are parsed in sequence and immediate ation is taken at each message
        //          in this way, for instance a set<something, value> immediateley imposes that something = value so that a successive
        //          get<something> effectively verifies if the previous operation was ok.
        //          BUT that have a problem if the agent just prepares data that is to be fed to a model that processes all info together.
        //          in such a case we use mode2.        
        // returns true if the canframe has been recognised. if so, any reply is sent if replies.size() > 0
//        bool process(const embot::prot::can::Frame &frame, std::vector<embot::prot::can::Frame> &replies);
        
        // mode2:   use when we uses a model that operates on data exchange
        enum class FILTER : uint8_t { doALL = 0, dontGET = 1, onlyGET = 2 }; 
        struct Result
        {
            bool recognised {false};
            bool processed {false};
        };            
        bool process(const embot::prot::can::Frame &frame, std::vector<embot::prot::can::Frame> &replies, Result &result, FILTER filter = FILTER::doALL);
        
//        // it parses and does action upon all messages that have a set(). it loads internally the get() ones        
//        bool process(const std::vector<embot::prot::can::Frame> &input, std::vector<embot::prot::can::Frame> &replies);
//        
//        // it finalises all the get() plus it loads the replies generated by the MBD code 
//        bool flush(std::vector<embot::prot::can::Frame> &replies);
#if 0
        usage:
        for(const auto &frame : inputframes)
        {
            // the step one just picks up the set<> commands that fill a shared data structure w/ setpoints, config, pids, etc 
            // there are typically no 
            theCANparserMC2.getInstance().process(theCANparserMC2::Step::one, frame, replies);
        }
        MBD..tick(); // the MBD will use the received data and fill up possible new data
        for(const auto &frame : inputframes)
        {
            // the step two just picks up the get<> commands that must contain values modified by the MBD 
            // they will generate reply frames.
            // but also, step two will form those frames that teh MBD asks to generate.         
            theCANparserMC2.getInstance().process(theCANparserMC2::Step::two, frame, replies);
        }
#endif        
        
        // it loads all. it calls agent on set<> or received sig<>, possibly produces acks that are pushed back in output (nearly never)
        // AND it defers all the get<> that are internally stored and processed by replies()
//        bool feed(const std::vector<embot::prot::can::Frame> &input, std::vector<embot::prot::can::Frame> &output);
        // time to call the agent.tick()
        // if there are deferred get<> it calls agent for them and push back replies in output 
//        bool replies(std::vector<embot::prot::can::Frame> &output);
//        // if the agent needs to emit frames it pushes back in output
//        bool emitted(std::vector<embot::prot::can::Frame> &output);
        
        // the above is always ok if it processes only set() commands. it may fail if it process a get() command about
        // something modified by a previous set(). So pls check this case.

    private:
        theCANparserMC2(); 
        ~theCANparserMC2(); 

    private:    
        struct Impl;
        std::unique_ptr<Impl> pImpl;     
    };       


} // namespace embot::app::application {


#endif  // include-guard


// - end-of-file (leave a blank line after)----------------------------------------------------------------------------
