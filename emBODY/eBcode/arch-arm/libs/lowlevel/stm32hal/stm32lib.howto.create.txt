
HOWTO: create a stm32hal library from a CUBE-MX project. and use it.


1.  Introduction

In here there are steps for generating a new stm32hal library starting from CUBE-MX.
The CUBE-MX project must generate a MDK project which uses the STM32 HAL library and a pair of 
.h/.c files for each HW peripheral.

1.1 Used terminology

Let's give now some terms: the board is named ${brd}, it mounts a mpu named ${mpu} of the family 
${mpufamily} and the STM32 HAL library has a driver version ${stmdriverversion}. The MDK project has a device
named ${MDKDEVICE}.

As an example, for board RFE we have: ${brd} = rfe, ${BRD} = RFE, ${MPU} = STM32L452xx, 
${MDKDEVICE} = STM32L452CEUx, 
${MPUFAMILY} = STM32L4xx, ${mpufamily} = stm32l4xx, ${mpufamilyshort} = stm32l4, ${MPUFAMILYSHORT} = STM32L4
${stmdriverversion} = v183, ${STMDRIVERVERSION} = V183

1.2 The steps

Here are the steps one must follow.

A.  Import the relevant CUBE-MX project without changes
B.  Define the macro which will shape all code for the compilation of the library 
C.  Adapt the API section to add references to the new board
D.  Adapt the SOURCE section. It is formed of the following parts.
    -   The DRIVER part keeps the code which CUBE-MX retrieves from the STM32 HAL (hardware abstraction layer) 
        STM LL (low level APIs). This code is specific for a family of MPUs (e.g., the STM32L4xx) and is regularly 
        updated over time. We keep this section MOSTLY UNCHANGED. 
    -   The BOARD part keeps those parts of code which CUBE-MX generates for the initialization of pins and peripherals
        of the MPU. We keep this part MOSTLY UNCHANGED.
    -   The CONFIG part contains code with macros and #include and some functions which glues all together. 
E.  Create a project which compiles all the code to generate a library which will be put inside the lib folder.
F.  Write down the ${MPU} name to use in the MDK project of a new application which links the library
G.  Provide a suitable startput file to be used in the MDK project.
H.  Use the library in a sample application named ${appl} by:
    -   generation a project for the given ${MPU},
    -   add to it the stm32hal.${brd}.${stmdriverversion}.lib, the stm32hal.startup.${brd}.${stmdriverversion}.s file, a copy of 
        stm32hal_stg_template.h in ./cfg/stm32hal_stg_${appl}.h which is required to define 
        the heap and stack sizes, 
    -   defining macro STM32HAL_BOARD_${BRD}, 
    -   defining macro STM32HAL_DRIVER_${STMDRIVERVERSION}
    -   adding in the C include paths the stm32hal/api folder to see the library funtions,
    -   adding the ./cfg folder to the path of the asm include paths,
    -   etc. 


2.  The steps in details for the first creation of the library

    In here, there are steps to follow if there is not yet any support for the board in the stm32lib.
    
    If you want to update the existing stm32lib for a board which has a new driver or add a new stm32lib for the
    same board but with a further driver, see next sections.    
    
2.1 CUBE-MX project

    Copy the MDK project generated by CUBE-MX into the stm32hal/cubemx/${brd} folder.
    Open the project and take note of the mpu name ${MPU} (VALE)in the tab C/C++ opened by Project menu -> option for target ... and of the mpu family ${MPUFAMILY} which is embedded
    in the project group named Drivers/${MPUFAMILY}_HAL_Driver.
    
    For instance, the board RFE has ${MPU} = STM32L452xx and ${MPUFAMILY} = STM32L4xx.
    
    
2.2 Board MACRO

    Specify a new STM32HAL_BOARD_${BRD} macro name. this is the macro which will shape any code of the .lib and of the APIs
    
    For instance, the board RFE will need STM32HAL_BOARD_RFE to be defined.
    VALE: where have I to specify the macro?
    
    
2.3 API section

    Adapt the files in the stm32hal/api folder to manage the new STM32HAL_BOARD_${BRD} macro name.

    a.  Edit file stm32hal_define.h to generate the following macros if STM32HAL_BOARD_${BRD} is defined:
            #define ${MPU}
            #define ${MPUFAMILYSHORT}
            #define STM32HAL_${MPUFAMILYSHORT}
            
            VALE: specify where is the file: it is not inside th driver folder(just generated with cubemx)
            VALE: MPUFAMILYSHORT is equal to MPUFAMILY without "xx" at the end.

            
        The first two macros are needed by the STM32 driver to shape its code. The third macro is available for the users of the library.
      
        For instance, for board RFE we have added:

        +   #elif   defined(STM32HAL_BOARD_RFE)
        +
        +       // it has a STM32L452xx mpu
        +       #if !defined(STM32L452xx)
        +       #define STM32L452xx
        +       #endif  
        +
        +       // of family STM32L4
        +       #if !defined(STM32L4)
        +       #define STM32L4
        +       #endif
        +
        +       // of family STM32L4 but in STM32HAL_ format   
        +       #if !defined(STM32HAL_STM32L4)
        +       #define STM32HAL_STM32L4
        +       #endif     
        + 
        +   
            #else
                    #error STM32HAL: you must define a STM32HAL_BOARD_${BRD}
            #endif

    b.  Edit file stm32hal_driver.h to define the proper macros and to include the API of the correct HAL driver 
        library provided by ST Microelectronics.
        
        The definition of the macros must be conditioned to STM32HAL_BOARD_${BRD} being defined.
        The macros are: STM32HAL_DRIVER_${STMDRIVERVERSION} and STM32HAL_DRIVER_VERSION
        
        For instance, for board RFE we have added:
        
        +   #elif   defined(STM32HAL_BOARD_RFE)
        +
        +   // only one possible driver
        +   #if !defined(STM32HAL_DRIVER_V183)
        +       #define STM32HAL_DRIVER_V183
        +   #endif
        +   #define STM32HAL_DRIVER_VERSION 183
        +
            #else
                #error STM32HAL: the STM32HAL_BOARD_${BRD} is undefined
            #endif        

        It is possible now to define extra macros which are required / possible only with specific versions
        of the driver. 
        
        For instance, since version v183 the CAN API has changed, hence we specify proper macros 
        required by the STM32 driver of this version or newer with:

        #if (STM32HAL_DRIVER_VERSION >= 183)
            // there is a new api for can
            #if !defined(USE_HAL_CAN_REGISTER_CALLBACKS)
            #define USE_HAL_CAN_REGISTER_CALLBACKS 1
            #endif  
        #endif        

        
        We can use macro STM32HAL_DRIVER_VERSION also to shape the user-defined code (see 
        embot_hw_can.cpp for an example).
        
        Only at the end we include the entry point of the stm32 driver we use.
        
        See following:
        
        #if     defined(STM32HAL_DRIVER_V172)    
            #include "../src/driver/stm32l4-v172/inc/stm32l4xx_hal.h"       
        #elif   defined(STM32HAL_DRIVER_V183)        
            #include "../src/driver/stm32l4-v183/inc/stm32l4xx_hal.h"
        #elif   defined(STM32HAL_DRIVER_V190)        
            #include "../src/driver/stm32l4-v190/inc/stm32l4xx_hal.h"
        #else
            #error STM32HAL: the STM32HAL_DRIVER_${VER} is not managed
        #endif

        Details will be clear after reading the DRIVER section.
          
    c.  Edit file stm32hal_board.h to include the API specific to the board support package of ${brd} as generated by CUBE-MX for the
        specific driver it has used.
        
        The inclusion must be conditioned to STM32HAL_BOARD_${BRD} being defined but also to the value of STM32HAL_DRIVER_VERSION.
        
        In this mode we can produce a library specific to a given board and with multiple versions of the driver.
        
        
        The following files will be included:
        
        #include "../src/board/${brd}/${stmdriverversion}/inc/stm32hal_driver_cfg_of_${brd}.h"
        #include "../src/board/${brd}/${stmdriverversion}/inc/main.h"
        #include "../src/board/${brd}/${stmdriverversion}/inc/${everyperipheral}.h" 
        
        where ${everyperipheral} can be adc, can, dma, i2c, rng, tim, etc.

        See the BOARD section to clarify which files to include. 
        
        
2.4 DRIVER section

    Create and populate the stm32hal/src/driver/${drivername} folder. 
    
    In here we shall copy the HAL driver provided by ST Microelectronics which CUBE-MX put inside the MDK project.
    We also add some config files which allow to shape the code of the library for the particular ${MPU} and ${BRD} pair.
    
    We typically use one specific driver for each board, but it is possible that two boards can share the same driver or
    also that one board can use two different drivers (maybe one to support a legacy application and one to support new features).
    
    For instance, the strain2 and mtb4 share the same library under the folder driver/stm32l4-v172, but the rfe board uses a 
    different library only for itself under driver/stm32l4-v183. Also, the strain2 can use either driver/stm32l4-v172 or driver/stm32l4-v190
    The library is specific of a given ${mpufamily} and is typically updated every six months. All our three boards are of the same
    ${mpufamily} and we could make all of them use only one library: the latest version. But that would require testing huge quantities of
    software at each new release of ST Microelectronics.
    
    To avoid continuous update and tests we have decided to allow multiple drivers.
    
    Even if it is possible to use any name for ${drivername} it is strongly advised to use: ${drivername} = ${mpufamilyshort}-${stmdriverversion}
    
    For the case of strain2 and mtb4 we use the same library and we have: ${drivername} = ${mpufamilyshort}-${stmdriverversion} = stm32l4-v172
    For the case of board rfe we have a new version of the library hence we have: ${drivername} = ${mpufamilyshort}-${stmdriverversion} = stm32l4-v183
    For the strain2 we also have a stm32l4-v190. 

    Here are the instructions.
    
    Add three subfolders: ${drivername}/inc, ${drivername}/src and ${drivername}/cfg

    Now, you must copy files in the following way: VALE: start pooint folder is icub-firmware\emBODY\eBcode\arch-arm\libs\lowlevel\stm32hal\src\driver\
    - in ${drivername}/src put: all files inside stm32hal/cubemx/${brd}/Drivers/${MPUFAMILY}_HAL_Driver/Src
      For the RFE board the folder is /stm32/cubemx/rfe/Drivers/STM32L4xx_HAL_Driver/Src
    - in ${drivername}/inc put: all files inside stm32hal/cubemx/${brd}/Drivers/${MPUFAMILY}_HAL_Driver/Inc
      they are all .h files related to the .c of the drivers of above.
    - in ${drivername}/src put: the file system_${mpufamily}.c
      For the RFE board the file is system_stm32l4xx.c which is in folder stm32hal/cubemx/rfe/Drivers/CMSIS/Device/ST/STM32L4xx/Source/Templates
    - in ${drivername}/inc put: all files in stm32hal\cubemx\${brd}\Drivers\CMSIS/Include    
    - in ${drivername}/inc put: all files in stm32hal\cubemx\${brd}\Drivers\CMSIS/Device/ST/${MPUFAMILY}/Include
    
    Now you must edit the file ${mpufamily}_hal.h and include file stm32hal_driver_cfg.h instead of ${mpufamily}_hal_conf.h
    For the case of board RFE (but it is the same for any board):
    
    +   // IIT-EXT
    +   #if defined(USE_STM32HAL)
    +       // path is referred to location of this file
    +       #include "../../../config/stm32hal_driver_cfg.h"
    +   #else
    +       #warning you are using a stm32hal file w/ USE_STM32HAL undefined ... are you sure?   
        /* Includes ------------------------------------------------------------------*/
        #include "stm32l4xx_hal_conf.h"
    +   #endif
    
    
    Then you must edit the file ${mpufamily}.h and add the following code before any other include or macro define:
    
    +   // IIT-EXT
    +   #include "../../../../api/stm32hal_define.h"
    
    This code will propagate all the proper macros to this file, so that the correct .h files are included.
    
    VERY IMPORTANT: change the name of all files *_template.c files in the ${drivername}/src into removed.*_template.c
    and ... DONT compile them into the library. 
    
    For instance, the file stm32l4xx_hal_msp_template MUST not be included. its code is already in stm32l4xx_hal_msp.c...
    the uvproject generated by cube-mx does not compile it.
    
 

2.5 CONFIG section

    - Add in file src/config/stm32hal_driver_cfg.h a section for STM32HAL_BOARD_${BRD} and STM32HAL_DRIVER_VERSION
      which includes the file stm32hal_driver_cfg_of_${brd}_${stmdriverversion}.h 
    - Edit the file stm32hal_driver_cfg_of_${brd}_${stmdriverversion}.h following instructions on the inside of a template file
        VALE that you can find in .....\cubemx\${brd}\Drivers\${MPUFAMILY}_HAL_Driver\Inc

    
2.6 BOARD section

    Look at the section Application/User in the MDK project. 
    Put all the .c files into folder stm32hal/src/board/${brd}/${stmdriverversion}/src and the relevant .h files 
    into stm32hal/src/board/${brd}/${stmdriverversion}/inc
    Remove the files you dont need for the .lib (e.g., the main.c file and others which are application specific).
    
    do following changes:
    -   in .h files use #include "stm32hal.h" instead of what ST uses to see the driver, which could be #include "${mpufamily}_hal.h"
        In older versions of the code generator, this inclusion was in every .h file, hence the change was:   
        
        +   // IIT-EXT
        +   #if defined(USE_STM32HAL)
        +       #include "stm32hal.h"
        +   #else
            #include "stm32l4xx_hal.h"
        +   #endif
        +   #include "main.h"   
        
        Since end of 2018, the code generator includes only main.h, hence the change is to be done in main.h with:

        +   // IIT-EXT
        +   #if defined(USE_STM32HAL)
        +       #include "stm32hal.h"
        +   #else
            #include "stm32l4xx_hal.h"
        +   #endif
        
    -   remove the file ${mpufamily}_hal_conf.h   
        rename it into: removed.${mpufamily}_hal_conf.h

    -   in .c files: nothing so far.
    
    -   add a file board_${brd}_${stmdriverversion}.c which contains:
        -   in function stm32hal_board_init() all the code which is inside the function main() {}
        -   the function SystemClock_Config() but without HAL_SYSTICK_Config() VALE: volevi dire HAL_SYSTICK_CALLBACK?......... !
        -   the function _Error_Handler() or Error_Handler() as it is called with latest versions of cube-mx
        
        VALE: occorre mettere il disclaimer di st in board_mtb4.c etc?
        
    

    
2.7 PROJECT section
    
    make a new target .... with the following properties:
    -   name:               ${brd}-${stmdriverversion}
        the name of the target helps to understand the board and the driver version. There may be two or more targets for a given board. 
    -   Device:             ${MDKDEVICE}
    -   C/C++ define:       USE_STM32HAL STM32HAL_BOARD_${BRD} STM32HAL_DRIVER_${STMDRIVERVERSION}
    -   C/C++ includes:     ..\api;..\src\driver\${drivername}\inc;..\src\board\${brd}\${stmdriverversion}\inc
    -   C/C++ optimization  -Os balanced
    -   C/C++ language      C++14 & C99
    
    make two new sections:
    -   driver-${mpufamilyshort}-${stmdriverversion}
        add in it all the files in folder stm32hal/src/driver/${drivername}/src WHICH ARE in the original MDK project.
        VERY IMPORTANT: if you add more files, then it may be that you do something wrong.  For instance, the driver src folder contains
        some *_template.c files which MUST NOT be compiled.
    -   board-${brd}-${stmdriverversion}
        add in it all the files in folder stm32hal/src/board/${brd}/${stmdriverversion}/src which are not tagged removed.*
    ETC.
    You must produce a stm32hal.${brd}.${stmdriverversion}.lib target ... stm32hal.strain2.v190.lib
    

    
    
2.8 STARTUP file

    Get the startup .s file used by the mdk project, rename it into stm32hal.startup.${brd}.${stmdriverversion}.template.s and
    put it into folder stm32hal/startup. 
    
    This file will have default values of Stack_Size and Heap_Size.
    
      
    
3.  The result

    At the end of the process we shall have:
    - a library named stm32hal/lib/stm32hal.${brd}.${stmdriverversion}.lib (e.g., stm32hal.strain2.v190.lib)
    - a unique point of inclusion with file stm32hal/api/stm32hal.h
    - a startup template file in stm32hal/stratup/stm32hal.startup.${brd}.${stmdriverversion}.template.s (e.g., stm32hal.startup.strain2.v190.template.s)
    
    
4. The use of the library

    build a MDK project with options:
    -   Device:             ${MDKDEVICE}
    -   C/C++ define:       USE_STM32HAL STM32HAL_BOARD_${BRD} STM32HAL_DRIVER_${STMDRIVERVERSION}
    -   C/C++ includes:     location of stm32hal.h; ... whatever else    
    -   ASM misc controls:  none (to have compatibilty with compiler armclang)
    -   etc
    
    add:
    -   the library stm32hal.${brd}.${stmdriverversion}.lib,
    -   a copy of the relevant file stm32hal.startup.${brd}.${stmdriverversion}.template.s properly renamed, 
        where YOU SHALL ADJUST heap and stack sizes.
    -   a file with main() {} which eventually calls:
            stm32hal_config_t cfg = {0};
            cfg.tick1ms_init = config.stm32hal.init1millitick;  // it inits the tick
            cfg.tick1ms_get = config.stm32hal.get1millitick;    // it gets the tick
            
            stm32hal_init(&cfg);
            
    VERY IMPORTANT
    One can implement the 1 ms tick funtions as wanted. 
    
    There are examples for that.
    - in icub-firmware\emBODY\eBcode\arch-arm\board\mtb4\examples\stm32app there is a basic example 
      which uses the systick and just the stm32hal library
    - in icub-firmware\emBODY\eBcode\arch-arm\board\mtb4\examples\embotapp there is a basic example
      which uses the systick and a few number of embot objects
    - in icub-firmware\emBODY\eBcode\arch-arm\board\mtb4\examples\embotappcan there is a skeleton
      application for can messaging with the use of teh systeick and embot objects.
     
    Another solution, the one used in our projects is to use the osal RTOS and the embot objects.    
    See code of any ${brd}-bootloader project for examples.
    
 

5.  The steps in details for updating the library with a new version of the STM32 driver

    The frequency with which STM updates its driver is about every six months, hence it may be required to use a new driver for a given board.
    
    The update can be easily done by running cube-mx project on a given board, checking any newer driver and generating a new mdk project with it.
    
    At this point, one can simply follow back section 2 and apply the relevant changes to the old library of the board.
    
    However, another possibility is to create a new alternative library for the board. The advantage is that the old library still exists.
    
    To do that, ... simply follow back section 2 and create all new folders etc as if it were a new library.
    
    
    
    
6.  Important changes across versions of the stm32 driver

    In version 183:
    -   the CAN API has changed ... now there is a new mode ()
    -   t
 
    
//  END OF DOCUMENT
    
    
